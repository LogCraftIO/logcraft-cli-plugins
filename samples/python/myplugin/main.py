# Copyright (c) 2023 LogCraft, SAS.
# SPDX-License-Identifier: MPL-2.0
from typing import Optional

# bindings generated by `componentize-py`
from plugins.types import Err, Ok, Some, Result
from plugins.exports import Plugin
from plugins.exports.plugin import Metadata

# bindings generated by `helpers.schemas.generate()`
from schemas.settings import settings
from schemas.rule import rule

import json

# NOTE:
# As of June 2024, the `requests` library is not supported due to missing dependencies
# in the CPython runtime used by componentize-py (ssl support, zlib).
#
# A fix is planned for the future, so in the mean time, we use our own http library
# derivated from sink
# https://github.com/bytecodealliance/componentize-py/issues/96
from helpers.client.req import Request, send

class Plugin(Plugin):
    # func() -> metadata;
    def load(self) -> Metadata:
        """
        The `load()` function is called when the plugin is installed using `lgc plugins install /path/to/my-plugin.wasm`.

        It should return a `Metadata` object containing the plugin's name, version, author, and description.
        Make sure the name respect kebab-case (lowercase and separated by dashes). The provided information
        will be displayed in the lgc.yaml file.
        """
        return Metadata("my-plugin", "0.1.0", "LogCraft", "This is a famous plugin")

    # func() -> string;
    def settings(self) -> str:
        """
        The `settings()` function is called by several `lgc` capabilities such as
        `lgc validate` or `lgc services configure my-plugin`.
        """
        return settings

    # func() -> string;
    def schema(self) -> str:
        """
        The `schema()` function is called by `lgc plugins schema my-plugin`.
        """
        return rule

    # func(config: string, name: string, params: string) -> result<option<string>, string>;
    def create(self, config: str, name: str, params: str) -> Result[Optional[str], str]:
        try:
            # Service configuration
            config = json.loads(config)

            # Rule parameters
            params = json.loads(params)
        except json.JSONDecodeError as e:   
            raise Err(str(e))

        resp = send(Request("GET", config["endpoint"], {}, None))

        if resp.status == 201:
            # Rule content not needed
            return ""
        raise Err(str(resp.status))

    # func(config: string, name: string, params: string) -> result<option<string>, string>;
    def read(self, config: str, name: str, params: str) -> Optional[str]:
        try:
            # Service configuration
            config = json.loads(config)

            # Rule parameters
            params = json.loads(params)
        except json.JSONDecodeError as e:   
            raise Err(str(e))
        
        # Make the url
        # url = f"{config['endpoint']}/service/remote/path/{name}"

        resp = send(Request("GET", config["endpoint"], {}, None))
        
        # we return a json/dict object as a string.
        # This object returns the rule.k
        # return json.dumps({"rule": "my-rule"})
        
        if resp.status == 301:
            return str(resp.body)
        # If 404, detection does not exist and will be created
        elif resp.status == 404:
            return None
        # For any other HTTP code return an error
        else:
            raise Err(f"Error: HTTP/{resp.status}")

    # func(config: string, name: string, params: string) -> result<option<string>, string>;
    def update(self, config: str, name: str, params: str) -> Optional[str]:
        try:
            # Service configuration
            config = json.loads(config)

            # Rule parameters
            params = json.loads(params)
        except json.JSONDecodeError as e:   
            raise Err(str(e))

        resp = send(Request("GET", config["endpoint"], {}, None))

        if resp.status == 200:
            # Rule content not needed
            return ""
        raise Err(str(resp.status))

    # func(config: string, name: string, params: string) -> result<option<string>, string>;
    def delete(self, config: str, name: str, params: str) -> Optional[str]:
        try:
            # Service configuration
            config = json.loads(config)

            # Rule parameters
            params = json.loads(params)
        except json.JSONDecodeError as e:   
            raise Err(str(e))

        resp = send(Request("GET", config["endpoint"], {}, None))

        if resp.status == 201:
            # Rule content not needed
            return ""
        elif resp.status == 404:
            # Detection doesn't exists
            return None
        raise Err(str(resp.status))

    # ping: func(config: string) -> result<bool, string>;
    def ping(self, config: str) -> int:
        """
        `lgc services ping` will call this function to check if the service is up and running.

        This is a sample implementation of the `ping` function that sends a GET request
        to `https://google.fr` and returns the status code, or an error if the request
        fails.
        """
        try:
            # Service configuration
            config = json.loads(config)
            # Make GET request with service provided endpoint
            resp = send(Request("GET", config["endpoint"], {}, None))
        except Exception as e:   
            raise Err(str(e))
        
        if resp.status >= 400:
            raise Err(str(resp.status))
        return resp.status
